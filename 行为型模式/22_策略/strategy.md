# 1、需求

鸭子问题

- 有各种鸭子（比如 野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫，飞行等）
- 显示鸭子的信息

# 2、传统方式解决

![1564014208837](images\传统方式图.png)

- 类图

  ![1564014394922](images\传统方式解决问题类图.png)

- 代码

- 传统方式解决鸭子问题分析和解决方案
  - 其他鸭子，都继承了Duck类，所以fly让所有子类都会飞，这是不正确的
  - 上面说的1的问题，其实是继承带来的问题：对类的局部改动，尤其是超类的局部改动，会影响其他部分。会有溢出效应
  - 为了改进1问题，我们可以通过覆盖fly方法来解决 =>覆盖解决
  - 问题又来了，如果我们有一个玩具鸭子ToyDuck，这样就需要ToyDuck去覆盖Duck的所有实现的方法  =>解决思路：**策略模 式**

# 3、策略模式

## 3.1、基本介绍

- 策略模式（Stategy Pattern）中，定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
- 这算法体现了几个设计原则：
  - 把变化的代码从不变的代码中分离出来
  - 针对接口编程而不是具体类（定义了策略接口）
  - 多用组合/聚合，少用继承（客户通过组合方式使用策略）

## 3.2、原理类图

![1564017910528](images\策略模式原理类图.png)

- 说明

  从上图可以看到，客户Context有成员变量strategy或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定。

# 4、使用策略模式解决问题

## 4.1、类图

![1564018484250](images\使用策略模式解决问题类图.png)

# 5、策略模式的注意实现和细节

- 策略模式的关键是：分析项目中变化部分（策略算法）和不变部分（使用者）
- 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性
- 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原代码，只需要添加一种策略（或者行为）即可，避免了使用多重转移语句（if...else  if...else）
- 提供了可以替换继承关系的办法：策略模式将算法封装在独立地Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展
- 需要注意的是：每添加一个策略就要增加一个类，当策略过多时会到时类数目庞大

