# 1、需求

编写一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：

![1563759249380](images\迭代器模式需求.png)

# 2、传统方式

传统的方式的问题分析

- 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的
- 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现遍历的操作
- 解决方式： ==》  迭代器模式

# 3、迭代器模式

## 3.1、基本介绍

- 迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式
- 如果我们的**集合元素是用不同的方式实现的**，有数组，还有java的集合类或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决
- 迭代器模式，提供一种遍历集合元素的同一接口，用一致的方法遍历集合元素，不需要知道集合对象底层的数据结构，即：不暴露其内部的结构

# 3.2、类图

![1563760268220](images\迭代器模式类图.png)

- 对原理类图的说明-即（迭代器模式的角色及职责）
  - Iterator：迭代器接口，是系统提供，含有 hasNext、next、remove等方法
  - ConcreteIterator：具体的迭代器类，管理迭代
  - Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦
  - ConcreteAggreage：具体的聚合，持有对象集合，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合
  - Client：客户端，通过Iterator和Aggregate依赖子类

# 4、迭代器模式应用实例

## 4.1、类图

 ![1563840350351](images\迭代器模式应用实例类图.png)

## 4.2、源码实例

# 5、迭代器模式在JDK-ArrayList集合应用的源码分析

## 5.1、类图

![1563844067854](images\迭代器模式的源码实现.png)

- 角色分析说明
  - 内部类Itr：充当具体实现迭代器Iterator的类，作为ArrayList内部类
  - List：就是充当了聚合接口，含有一个iterator()方法，返回一个迭代器对象
  - ArrayList：是实现聚合接口List的子类，实现了iterator()
  - Iterator接口：系统提供
  - 迭代器模式解决了：不同集合（ArrayList、LinkedList）统一遍历问题

# 6、迭代器模式的注意事项和细节

- 优点

  - 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。

  - 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。

  - 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。

  - 当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式

- 缺点

  - 每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类

