# 1、需求

- 星巴克咖啡订单项目（咖啡馆)：
  - 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式
    咖啡）、Decaf(无因咖啡）
  - 调料：Milk、Soy(豆浆)、Chocolate
  - 要求在扩展**新的咖啡种类**时，具有良好的扩展性、改动方便、维护方便
  - 使用OO的方式来计算不同种类咖啡的**费用**：客户可以点**单品咖啡**，也可以**单品咖**
    **啡+调料组合**。

# 2、解决方式

## 2.1、方案一（类爆炸）

- ![1563279844554](images\传统解决方式.png)

- 解决方式的分析
  - Drink：是一个抽象类 ，表示饮料
  - des：就是对咖啡的描述，比如咖啡的名字
  - cost()：就是计算费用，Drink类中做成一个抽象方法
  - Decaf：就是单品咖啡，继承Drink，并实现cost
  - Espress && Milk ：就是单品咖啡 + 调料，这种组合很多
  - 问题出现：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸。

## 2.2、方案二（好点）

- ![1563280418156](images\解决方式2.png)
- 解决方式的分析
  - 方案2可以控制类的数量，不至于造成很多的类
  - 在增加或者删除调料种类时，代码的维护量很大
  - 考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应int
  - 可以考虑使用 **装饰者模式**

# 3、装饰者模式

## 3.1、定义

- 装饰者模式：**动态地**将新功能**附加到对象上**。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（ocp）
- 这里提到的**动态的新功能附加到对象**和**ocp原则**，在后面的应用实例上会以代码的形式体现。

## 3.2、原理

- 装饰者模式就像打包一个快递
  - 主体：比如：陶瓷、衣服(Component)        //被装饰者
  - 包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)      //装饰者
- Component
  - 主体：比如类似前面的Drink
- ConcreteComponent和Decorator
  - ConcreteComponent：具体的主体，比如前面的各个单品咖啡
  - Decorator装饰者，比如各调料
- 在如图的**Component 与 ConcereteComponent之间**，如果ConcreteComponent类很名本可以设计依中将热有的部分提取出来，抽象成一个类

![1563281447450](images\原理图.png)



## 3.3、装饰者模式解决星巴克咖啡订单

- 用装饰者模式设计的方案

  ![1563281722346](images\装饰者模式解决问题.png)

- 说明

  - Drink：就是前面说的抽象类，Component
  - ShortBlack：单品咖啡
  - Decorator：是一个装饰类，含有一个被装饰的对象（Drink obj）
  - Decorator的cost方法进行一个费用的叠加计算，递归的计算价格

- 装饰者模式下的订单：2份巧克力 + 一份奶的LongBlack

  ![1563282087376](images\装饰者模式下的订单.png)

- 说明
  - Mike包含了LongVlack
  - 一份Chocolate包含了（Milk + LongBlack）
  - 一份Chocolate包含了（Chocolate + Milk + LongBlack）
  - 这样不管是什么形式的单品咖啡 + 调料组合，通过递归方式可以方便的组合和维护。

- 代码实例（src）

# 4、装饰者模式在JDK应用的源码分析

- Java的IO结构，FilterInputStream就是一个装饰者

![1563284280473](images\IO结构.png)

